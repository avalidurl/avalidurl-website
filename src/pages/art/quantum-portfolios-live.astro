---
import Layout from '../../layouts/Layout.astro';
---

<Layout title="Quantum Portfolios - Interactive Art">
  <main class="quantum-portfolios">
    <div class="artwork-header" id="headerPanel">
      <h1>Quantum Portfolios</h1>
      <p class="subtitle">Interactive exploration of Modern Portfolio Theory through quantum mechanics</p>
      <div class="controls">
        <button id="togglePhysics">Toggle Physics</button>
        <button id="resetPortfolio">Reset Portfolio</button>
        <button id="hideUI">Hide UI</button>
        <button id="enableMusic">ðŸŽµ Enable Music</button>
        <div class="risk-return">
          <span>Risk: <span id="riskDisplay">--</span>%</span>
          <span>Return: <span id="returnDisplay">--</span>%</span>
        </div>
      </div>
    </div>

    <canvas id="quantumCanvas"></canvas>
    
    <div class="portfolio-panel" id="portfolioPanel">
      <h3>Portfolio Weights</h3>
      <div class="asset-weights">
        <div class="asset">
          <label>Tech Stocks</label>
          <input type="range" id="tech" min="0" max="100" value="25">
          <span class="weight-value">25%</span>
        </div>
        <div class="asset">
          <label>Bonds</label>
          <input type="range" id="bonds" min="0" max="100" value="25">
          <span class="weight-value">25%</span>
        </div>
        <div class="asset">
          <label>Real Estate</label>
          <input type="range" id="realestate" min="0" max="100" value="25">
          <span class="weight-value">25%</span>
        </div>
        <div class="asset">
          <label>Commodities</label>
          <input type="range" id="commodities" min="0" max="100" value="25">
          <span class="weight-value">25%</span>
        </div>
      </div>
    </div>

    <div class="concept-info" id="conceptPanel">
      <h3>About Quantum Portfolios</h3>
      <p>
        This interactive artwork visualizes Modern Portfolio Theory through quantum mechanics. 
        Each asset class forms particle clouds with quantum behaviors - larger weights create 
        denser, more active particle fields.
      </p>
      <p>
        <strong>ðŸ’¡ Monetization Ideas:</strong> NFT collections, licensed installations for financial institutions, 
        premium real-time data feeds, VR gallery experiences.
      </p>
    </div>

    <!-- Hidden UI Toggle -->
    <button id="showUI" class="show-ui-btn" style="display: none;">Show Controls</button>
  </main>
</Layout>

<style>
  .quantum-portfolios {
    min-height: 100vh;
    background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
    color: #e8f4fd;
    position: relative;
    overflow: hidden;
  }

  .artwork-header {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 100;
    max-width: 400px;
  }

  .artwork-header h1 {
    font-size: 2.5rem;
    font-weight: 600;
    margin: 0 0 0.5rem 0;
    color: #ffffff;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
  }

  .subtitle {
    font-size: 1.1rem;
    color: #ffffff;
    margin: 0 0 1rem 0;
    line-height: 1.4;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    font-weight: 400;
  }

  .controls {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .controls button {
    background: rgba(255, 255, 255, 0.9);
    border: 2px solid #4fc3f7;
    color: #0a0a0f;
    padding: 0.75rem 1.25rem;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
    font-weight: 600;
    text-shadow: none;
  }

  .controls button:hover {
    background: #4fc3f7;
    color: #ffffff;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  }

  .risk-return {
    display: flex;
    gap: 1rem;
    font-size: 1rem;
    margin-top: 0.75rem;
    font-weight: 500;
  }

  .risk-return span {
    background: rgba(255, 255, 255, 0.95);
    color: #0a0a0f;
    padding: 0.5rem 0.75rem;
    border-radius: 6px;
    border: 2px solid #4fc3f7;
    font-weight: 600;
    text-shadow: none;
  }

  #quantumCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1;
  }

  .portfolio-panel {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border: 3px solid #4fc3f7;
    border-radius: 12px;
    padding: 1.5rem;
    min-width: 280px;
    z-index: 100;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
  }

  .portfolio-panel h3 {
    margin: 0 0 1rem 0;
    font-size: 1.3rem;
    color: #0a0a0f;
    font-weight: 700;
    text-shadow: none;
  }

  .asset-weights {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .asset {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .asset label {
    min-width: 90px;
    font-size: 1rem;
    color: #0a0a0f;
    font-weight: 600;
    text-shadow: none;
  }

  .asset input[type="range"] {
    flex: 1;
    height: 4px;
    background: rgba(79, 195, 247, 0.2);
    border-radius: 2px;
    outline: none;
    -webkit-appearance: none;
  }

  .asset input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    background: #4fc3f7;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid #0a0a0f;
  }

  .asset input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: #4fc3f7;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid #0a0a0f;
  }

  .weight-value {
    min-width: 40px;
    text-align: right;
    font-size: 1rem;
    color: #0a0a0f;
    font-weight: 700;
  }

  .concept-info {
    position: absolute;
    bottom: 20px;
    left: 20px;
    max-width: 380px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border: 3px solid #4fc3f7;
    border-radius: 12px;
    padding: 1.5rem;
    z-index: 100;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
  }

  .concept-info h3 {
    margin: 0 0 1rem 0;
    font-size: 1.3rem;
    color: #0a0a0f;
    font-weight: 700;
    text-shadow: none;
  }

  .concept-info p {
    margin: 0 0 1rem 0;
    font-size: 0.95rem;
    line-height: 1.5;
    color: #0a0a0f;
    font-weight: 400;
    text-shadow: none;
  }

  .concept-info p:last-child {
    margin-bottom: 0;
  }

  .show-ui-btn {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(255, 255, 255, 0.9);
    border: 2px solid #4fc3f7;
    color: #0a0a0f;
    padding: 0.75rem 1.25rem;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 600;
    z-index: 1000;
    transition: all 0.3s ease;
  }

  .show-ui-btn:hover {
    background: #4fc3f7;
    color: #ffffff;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  }

  @media (max-width: 768px) {
    .artwork-header {
      position: relative;
      max-width: none;
      padding: 1.5rem;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 3px solid #4fc3f7;
    }

    .artwork-header h1 {
      font-size: 2rem;
      color: #0a0a0f;
      text-shadow: none;
    }

    .subtitle {
      color: #0a0a0f;
      text-shadow: none;
    }

    .portfolio-panel,
    .concept-info {
      position: relative;
      bottom: auto;
      right: auto;
      left: auto;
      margin: 1rem;
      max-width: none;
    }

    #quantumCanvas {
      height: 60vh;
      position: relative;
    }
  }
</style>

<script>
  // Quantum Portfolio Visualization
  let canvas, ctx;
  let particles = [];
  let mouse = { x: 0, y: 0 };
  let time = 0;
  let physicsEnabled = true;
  let musicEnabled = false;
  let audioContext, oscillators = {};
  
  // Portfolio data with enhanced visual properties
  const assets = {
    tech: { weight: 0.25, color: '#4fc3f7', return: 0.12, risk: 0.20, particles: [], baseCount: 50 },
    bonds: { weight: 0.25, color: '#81d4fa', return: 0.06, risk: 0.08, particles: [], baseCount: 50 },
    realestate: { weight: 0.25, color: '#b3e5fc', return: 0.10, risk: 0.15, particles: [], baseCount: 50 },
    commodities: { weight: 0.25, color: '#e1f5fe', return: 0.08, risk: 0.25, particles: [], baseCount: 50 }
  };

  class QuantumParticle {
    constructor(x, y, asset) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random() - 0.5) * 2;
      this.vy = (Math.random() - 0.5) * 2;
      this.asset = asset;
      this.size = Math.random() * 3 + 2;
      this.phase = Math.random() * Math.PI * 2;
      this.uncertainty = asset.risk * 50;
      this.entanglement = Math.random();
    }

    update() {
      if (!physicsEnabled) return;

      time += 0.016;
      
      // Quantum uncertainty principle
      const uncertainty = Math.sin(time + this.phase) * this.uncertainty;
      
      // Entanglement with other particles
      particles.forEach(other => {
        if (other !== this && other.asset !== this.asset) {
          const dx = other.x - this.x;
          const dy = other.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 100) {
            const force = this.entanglement * (100 - distance) / 100;
            this.vx += (dx / distance) * force * 0.001;
            this.vy += (dy / distance) * force * 0.001;
          }
        }
      });

      // Portfolio weight influence
      const centerX = canvas.width * 0.5;
      const centerY = canvas.height * 0.5;
      const attractionStrength = this.asset.weight * 0.001;
      
      this.vx += (centerX - this.x) * attractionStrength;
      this.vy += (centerY - this.y) * attractionStrength;
      
      // Apply uncertainty
      this.vx += Math.sin(time * 2 + this.phase) * 0.1;
      this.vy += Math.cos(time * 2 + this.phase) * 0.1;
      
      // Update position
      this.x += this.vx;
      this.y += this.vy;
      
      // Damping
      this.vx *= 0.99;
      this.vy *= 0.99;
      
      // Boundary conditions
      if (this.x < 0 || this.x > canvas.width) this.vx *= -0.5;
      if (this.y < 0 || this.y > canvas.height) this.vy *= -0.5;
      
      this.x = Math.max(0, Math.min(canvas.width, this.x));
      this.y = Math.max(0, Math.min(canvas.height, this.y));
    }

    draw() {
      const alpha = 0.6 + Math.sin(time + this.phase) * 0.3;
      
      // Draw quantum field
      const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 4);
      gradient.addColorStop(0, this.asset.color + Math.floor(alpha * 255).toString(16).padStart(2, '0'));
      gradient.addColorStop(1, this.asset.color + '00');
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size * 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw particle core
      ctx.fillStyle = this.asset.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function init() {
    canvas = document.getElementById('quantumCanvas');
    ctx = canvas.getContext('2d');
    
    resizeCanvas();
    createParticles();
    setupEventListeners();
    animate();
  }

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  function createParticles() {
    particles = [];
    
    Object.keys(assets).forEach(assetKey => {
      const asset = assets[assetKey];
      // More dramatic particle count based on weight (0-400 particles)
      const particleCount = Math.floor(asset.weight * 400);
      asset.particles = [];
      
      // Create particles in clusters based on asset type
      const clusterX = (canvas.width / 4) * (Object.keys(assets).indexOf(assetKey) + 0.5);
      const clusterY = canvas.height / 2;
      
      for (let i = 0; i < particleCount; i++) {
        // Spread particles in clusters but allow movement
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 200;
        const x = clusterX + Math.cos(angle) * radius;
        const y = clusterY + Math.sin(angle) * radius;
        
        const particle = new QuantumParticle(x, y, asset);
        particles.push(particle);
        asset.particles.push(particle);
      }
    });
    
    // Update music based on portfolio
    updateMusic();
  }

  function updatePortfolioMetrics() {
    let totalReturn = 0;
    let totalRisk = 0;
    
    Object.values(assets).forEach(asset => {
      totalReturn += asset.weight * asset.return;
      totalRisk += asset.weight * asset.weight * asset.risk * asset.risk;
    });
    
    // Add correlation effects (simplified)
    totalRisk = Math.sqrt(totalRisk) * 1.2;
    
    document.getElementById('returnDisplay').textContent = (totalReturn * 100).toFixed(1);
    document.getElementById('riskDisplay').textContent = (totalRisk * 100).toFixed(1);
  }

  // Music generation based on portfolio
  function initAudio() {
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      Object.keys(assets).forEach((assetKey, index) => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        // Different frequencies for each asset
        const baseFreq = [220, 330, 440, 550][index]; // A3, E4, A4, C#5
        oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.start();
        oscillators[assetKey] = { osc: oscillator, gain: gainNode, baseFreq };
      });
    } catch (e) {
      console.log('Audio not supported');
    }
  }

  function updateMusic() {
    if (!musicEnabled || !audioContext) return;
    
    Object.keys(assets).forEach(assetKey => {
      const asset = assets[assetKey];
      const osc = oscillators[assetKey];
      
      if (osc) {
        // Volume based on weight
        const volume = asset.weight * 0.1;
        osc.gain.gain.exponentialRampToValueAtTime(volume + 0.001, audioContext.currentTime + 0.1);
        
        // Frequency modulation based on risk
        const freqMod = asset.risk * 50;
        osc.osc.frequency.exponentialRampToValueAtTime(osc.baseFreq + freqMod, audioContext.currentTime + 0.1);
      }
    });
  }

  // UI Management
  function hideUI() {
    document.getElementById('headerPanel').style.display = 'none';
    document.getElementById('portfolioPanel').style.display = 'none';
    document.getElementById('conceptPanel').style.display = 'none';
    document.getElementById('showUI').style.display = 'block';
  }

  function showUI() {
    document.getElementById('headerPanel').style.display = 'block';
    document.getElementById('portfolioPanel').style.display = 'block';
    document.getElementById('conceptPanel').style.display = 'block';
    document.getElementById('showUI').style.display = 'none';
  }

  function setupEventListeners() {
    // Portfolio weight sliders
    Object.keys(assets).forEach(assetKey => {
      const slider = document.getElementById(assetKey);
      slider.addEventListener('input', (e) => {
        const newWeight = e.target.value / 100;
        assets[assetKey].weight = newWeight;
        
        // Update particle count dramatically (0-400 particles)
        const newParticleCount = Math.floor(newWeight * 400);
        const currentCount = assets[assetKey].particles.length;
        
        if (newParticleCount > currentCount) {
          // Add new particles in clusters
          const clusterX = (canvas.width / 4) * (Object.keys(assets).indexOf(assetKey) + 0.5);
          const clusterY = canvas.height / 2;
          
          for (let i = 0; i < newParticleCount - currentCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 200;
            const x = clusterX + Math.cos(angle) * radius;
            const y = clusterY + Math.sin(angle) * radius;
            
            const particle = new QuantumParticle(x, y, assets[assetKey]);
            particles.push(particle);
            assets[assetKey].particles.push(particle);
          }
        } else if (newParticleCount < currentCount) {
          const toRemove = currentCount - newParticleCount;
          for (let i = 0; i < toRemove; i++) {
            const particle = assets[assetKey].particles.pop();
            const index = particles.indexOf(particle);
            if (index > -1) particles.splice(index, 1);
          }
        }
        
        // Update display
        e.target.nextElementSibling.textContent = Math.round(newWeight * 100) + '%';
        updatePortfolioMetrics();
        updateMusic();
      });
    });

    // Controls
    document.getElementById('togglePhysics').addEventListener('click', () => {
      physicsEnabled = !physicsEnabled;
      const btn = document.getElementById('togglePhysics');
      btn.textContent = physicsEnabled ? 'Pause Physics' : 'Resume Physics';
    });

    document.getElementById('resetPortfolio').addEventListener('click', () => {
      Object.keys(assets).forEach(assetKey => {
        assets[assetKey].weight = 0.25;
        document.getElementById(assetKey).value = 25;
        document.querySelector(`#${assetKey} + .weight-value`).textContent = '25%';
      });
      createParticles();
      updatePortfolioMetrics();
    });

    document.getElementById('hideUI').addEventListener('click', hideUI);
    document.getElementById('showUI').addEventListener('click', showUI);

    document.getElementById('enableMusic').addEventListener('click', () => {
      if (!musicEnabled) {
        initAudio();
        musicEnabled = true;
        document.getElementById('enableMusic').textContent = 'ðŸ”‡ Disable Music';
        updateMusic();
      } else {
        musicEnabled = false;
        Object.values(oscillators).forEach(osc => {
          if (osc.gain) osc.gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
        });
        document.getElementById('enableMusic').textContent = 'ðŸŽµ Enable Music';
      }
    });

    // Mouse interaction
    canvas.addEventListener('mousemove', (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      
      // Attract particles to mouse
      particles.forEach(particle => {
        const dx = mouse.x - particle.x;
        const dy = mouse.y - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 150) {
          const force = (150 - distance) / 150 * 0.002;
          particle.vx += (dx / distance) * force;
          particle.vy += (dy / distance) * force;
        }
      });
    });

    window.addEventListener('resize', () => {
      resizeCanvas();
      createParticles();
    });
  }

  function animate() {
    ctx.fillStyle = 'rgba(10, 10, 15, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    particles.forEach(particle => {
      particle.update();
      particle.draw();
    });
    
    // Draw connections between entangled particles
    ctx.strokeStyle = 'rgba(79, 195, 247, 0.1)';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < particles.length; i += 5) {
      for (let j = i + 5; j < particles.length; j += 5) {
        const p1 = particles[i];
        const p2 = particles[j];
        const distance = Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        
        if (distance < 100 && p1.entanglement * p2.entanglement > 0.7) {
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }
    }
    
    requestAnimationFrame(animate);
  }

  // Initialize when page loads
  document.addEventListener('DOMContentLoaded', () => {
    init();
    updatePortfolioMetrics();
  });
</script>
</Layout>